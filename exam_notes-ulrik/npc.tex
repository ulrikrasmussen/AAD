\newcommand{\NP}{\mathop{\text{NP}}}
\newcommand{\CNP}{\mathop{\text{co-NP}}}
\renewcommand{\P}{\mathop{\text{P}}}

\subsection{Problem examples}
The following problems are NP-complete:
\begin{itemize}
\item Hamiltonian cycle (cycle that contains all edges of a graph). On
  the other hand, finding an Euler tour is polynomial.
\item Longest simple path. Shortest path is polynomial.
\item 3-sat. 2-sat is polynomial!
\end{itemize}

\subsection{Definition of NPC}
\begin{itemize}
\item We define the complexity class NP as the problems that can be
  decided in polynomial time by a non-deterministic turing
  machine. Equivalently, it can also be defined as the problems that
  can be verified in polynomial time.
\item A problem H is NP-\emph{hard} if any problem in NP can be
  reduced to an instance of H in polynomial time. I.e. H is at least
  as hard as any problem in NP.
\item An NP-Complete problem is an NP-hard problem that is also in NP.
\end{itemize}

\subsection{Showing NPC}
\begin{itemize}
\item Any optimization problem has a corresponding decision problem
  that is at least as easy, or vice-versa, that the optimization
  problem is at least as hard as the decision problem.
\item All problems in NP are decision problems.
\item Showing that a problem H is NPC amounts to showing that there
  exists a polynomial time reduction from an exisiting NPC problem to
  H, and also that H itself is in NP.
\item A \emph{reduction} from A to B is a polynomial time algorithm
  than converts a problem instance $\alpha$ in A to an instance
  $\beta$ in B, for which it holds that $\alpha$ is accepted iff
  $\beta$ is accepted.
\end{itemize}

\subsection{Polynomial time}
\begin{itemize}
\item Any problem instance $i$ has a \emph{concrete representation}
  over some alphabet $\Sigma$. We almost always choose $\Sigma =
  \{0,1\}$.
\item A problem in P is a problem whose concrete instances $e(Q)$ can
  be accepted by a polynomial time algorithm in $O(n^k)$ steps for
  some encoding $e$. By simulating a turing machine for $cn^k$ steps
  for some constant $c$, we can build a decider. Hence any problem in
  P is decidable in polynomial time.
\item The running time depends on the encoding.
\item For some set $I$ of problem instances, we say that encodings
  $e_1$ and $e_2$ are polynomially related if there exists
  polynomially computable functions $f_{12}$ and $f_{21}$ which
  convert instances $e_1(i)$ to $e_2(i)$ and vice-versa
\end{itemize}


\subsection{Polynomial time verification}

\begin{itemize}
\item We call a two-argument algorithm $A$ with ordinary input $x$ and
  binary input $y$ a \emph{verification algorithm}. We say that $A$
  \emph{verifies} an input string $x$ if there is a certificate $y$
  such that $A(x,y) = 1$. The \emph{language verified} by $A$ is
$$
 L = \{ x \in \{0,1\}^\star : \exists y \in \{0,1\}^\star . A(x,y) = 1 \}.
$$
\end{itemize}


\subsection{The class NP}

\begin{itemize}
\item For a language $L$, we have $L \in \NP$ iff there exists a
  polynomial time algorithm $A$ that verified $L$. In other words,
  there is an algorithm $A$ and a constant $c$ such that
$$
 L = \{ x \in \{0,1\}^\star : \exists y \in \{0,1\}^\star . |y| = O(|x|^c) \land A(x,y)=1 \}
$$
\item It is unknown whether $\P=\NP$.
\item The class co-NP is the languages whose complement belong to NP.
\item Likewise, it is unknown whether $\NP = \CNP$.

\end{itemize}

\subsection{Reducibility}
\begin{itemize}
\item A language $L_1$ is \emph{polynomial-time} reducible to $L_2$,
  or $L_1 \leq_p L_2$ iff there exists a polynomial-time computable
  function $f$ such that $x \in L_1 \iff f(x) \in L_2$.
\item It is easy to show that if $L_1 \leq_p L_2$ and $L_2 \in \P$,
  then $L_1 \in \P$.
\item $L$ is NPC iff $L \in \NP$ and $L' \leq_p L$ for any $L' \in
  \NP$.
\end{itemize}

\subsubsection{Circuit satisfiability}
\begin{itemize}
\item A \emph{boolean combinational circuit} consists of one or more
  logical gates (and, or, not) interconnected by wires. A set of wires
  are denoted as \emph{input wires} and another set as \emph{output
    wires}.
\item The language CIRCUIT-SAT contains the encodings of all circuits
  that are satisfiable, i.e. for which there exists some configuration
  of inputs which produces a positive output.
\item Every problem in NP reduces to CIRCUIT-SAT, as we can simply
  model a computer using circuits. We can only model the computer
  doing a finite number of steps, but since there is a polynomial
  verifier for any problem in NP, we have an upper bound on the number
  of steps we have to simulate.
\end{itemize}

\subsection{NPC proofs}
\todo{Exercise proofs from section 34.4}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "notes"
%%% End:
